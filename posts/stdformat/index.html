<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>String formatting the cool way with C++20 std::format() | Madrid C/C++</title><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="String formatting the cool way with C++20 std::format()" /><meta name="author" content="Manu Sanchez" /><meta property="og:locale" content="en_US" /><meta name="description" content="Through its 40 years of history C++ has had multiple “tries” to bring text formatting to the language. First it was the printf() family of functions inherited from C:" /><meta property="og:description" content="Through its 40 years of history C++ has had multiple “tries” to bring text formatting to the language. First it was the printf() family of functions inherited from C:" /><link rel="canonical" href="https://madridccppug.github.io/posts/stdformat/" /><meta property="og:url" content="https://madridccppug.github.io/posts/stdformat/" /><meta property="og:site_name" content="Madrid C/C++" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-11-06T00:46:34+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="String formatting the cool way with C++20 std::format()" /><meta name="twitter:site" content="@madridccppug" /><meta name="twitter:creator" content="@Manu Sanchez" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"author":{"@type":"Person","name":"Manu Sanchez"},"description":"Through its 40 years of history C++ has had multiple “tries” to bring text formatting to the language. First it was the printf() family of functions inherited from C:","@type":"BlogPosting","headline":"String formatting the cool way with C++20 std::format()","dateModified":"2020-11-06T00:46:34+01:00","datePublished":"2020-11-06T00:46:34+01:00","url":"https://madridccppug.github.io/posts/stdformat/","mainEntityOfPage":{"@type":"WebPage","@id":"https://madridccppug.github.io/posts/stdformat/"},"@context":"https://schema.org"}</script><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="preload" as="style" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /><link rel="preload" as="script" href="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"> <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" async></script> <script src="/assets/js/post.min.js" async></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-T9QDTFCD70"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-T9QDTFCD70'); </script> <script src="/app.js" defer></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/" alt="avatar"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">Madrid C/C++</a></div><div class="site-subtitle font-italic">Grupo de usuarios (Madrid, España).</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <span id="mode-toggle-wrapper"> <i class="mode-toggle fas fa-sun" dark-mode-invisible></i> <i class="mode-toggle fas fa-moon" light-mode-invisible></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.mode != null) { if (this.mode == ModeToggle.DARK_MODE) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.mode != null) { if (self.mode == ModeToggle.DARK_MODE) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span> <span class="icon-border"></span> <a href="https://github.com/madridccppug" target="_blank"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/madridccppug" target="_blank"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['madridccppug','gmail.com'].join('@')" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>String formatting the cool way with C++20 std::format()</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>String formatting the cool way with C++20 std::format()</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Nov 6, 2020, 12:46 AM +0100" > Nov 6, 2020 <i class="unloaded">2020-11-06T00:46:34+01:00</i> </span> by <span class="author"> Manu Sanchez </span></div><div> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Nov 7, 2020, 6:39 PM +0100" > Nov 7, 2020 <i class="unloaded">2020-11-07T18:39:01+01:00</i> </span></div></div><div class="post-content"><p>Through its 40 years of history C++ has had multiple “tries” to bring text formatting to the language. First it was the <code class="language-plaintext highlighter-rouge">printf()</code> family of functions inherited from C:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span><span class="s">"hello %s/n"</span><span class="p">,</span> <span class="s">"world!"</span><span class="p">);</span>
</pre></table></code></div></div><p>Succint, well known, “fast”, it certainly does the job. It was so successful due to its ubiquitousness that <em>“printf-driven-debugging”</em> became a thing, to a point that <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Dynamic-Printf.html#Dynamic-Printf">debuggers</a> and <a href="https://code.visualstudio.com/docs/editor/debugging#_logpoints">IDEs</a> have integrated <code class="language-plaintext highlighter-rouge">printf()</code>-like APIs these days.</p><blockquote><p>Let’s be honest, it’s 2020 and we all still do printf-debugging from time to time.</p></blockquote><p>But from its simplicity came its weakness: <code class="language-plaintext highlighter-rouge">printf()</code> and related functions work with built-in C types only (<code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">const char*</code> strings, etc), formatting is not type safe, and the multi-argument API is based on arcane <a href="https://en.cppreference.com/w/cpp/utility/variadic"><code class="language-plaintext highlighter-rouge">varargs</code></a>.</p><p>Some years later people started to work on alternatives to the C’s IO APIs, with type safety and integration of user defined types in mind. This work would became what we now know as the standard <a href="https://en.cppreference.com/w/cpp/header/iostream"><code class="language-plaintext highlighter-rouge">&lt;iostream&gt;</code></a> library:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">world</span><span class="p">{</span><span class="s">"world"</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"hello"</span> <span class="o">&lt;&lt;</span> <span class="n">world</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></table></code></div></div><p>But while it improved on the type safety and extensibility sides, it suffers from <a href="https://stackoverflow.com/questions/4340396/does-the-c-standard-mandate-poor-performance-for-iostreams-or-am-i-just-deali">bad performance</a>, <a href="https://en.cppreference.com/w/cpp/io/ios_base/pword">some arguably bad design decisions</a>, and a surprising obsession with chevrons that Richard Dean Anderson would certainly be proud of:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"oh yeah, "</span>
          <span class="o">&lt;&lt;</span> <span class="s">"this is "</span>
          <span class="o">&lt;&lt;</span> <span class="n">definitely</span><span class="p">()</span>
          <span class="o">&lt;&lt;</span> <span class="s">" not verbose "</span>
          <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">at_all</span> 
          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></table></code></div></div><p>C++20 will bring us a new text formatting API, <a href="https://en.cppreference.com/w/cpp/utility/format">the formatting library <code class="language-plaintext highlighter-rouge">&lt;format&gt;</code></a>, which tries to overcome the issues of streams but with the simplicity of <code class="language-plaintext highlighter-rouge">printf()</code>.</p><h2 id="a-modern-sprintf">A modern <code class="language-plaintext highlighter-rouge">sprintf()</code></h2><p><code class="language-plaintext highlighter-rouge">&lt;format&gt;</code> is a text formatting library based on three simple principles:</p><ul><li><strong>Placeholder-based formatting syntax</strong>, with support for indexed arguments and format specifications.<li><strong>Type-safe formatting</strong>, using variadic templates for multiple argument support.<li><strong>Support for user defined types</strong> through custom formatters.</ul><p>Its main function, <a href="https://en.cppreference.com/w/cpp/utility/format/format"><code class="language-plaintext highlighter-rouge">std::format()</code></a>, formats the given arguments and returns a string:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;format&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">message</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{}, {}!"</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Placeholders can be indexed, allowing us to change the order of the arguments or even repeat them. This two calls both return <code class="language-plaintext highlighter-rouge">"hello, world!"</code>:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{1}, {0}!"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"he{0}{0}o, {1}!"</span><span class="p">,</span> <span class="s">"l"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">);</span>
</pre></table></code></div></div><p>In adition to <code class="language-plaintext highlighter-rouge">std::format()</code> the library provides <a href="https://en.cppreference.com/w/cpp/utility/format/format_to"><code class="language-plaintext highlighter-rouge">std::format_to()</code></a>, which allows us to write the resulting string into an iterator instead of allocating a <code class="language-plaintext highlighter-rouge">std::string</code> directly. This comes handy to dump the formatted string into any kind of iterator-based storage, like a file:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">file</span><span class="p">{</span><span class="s">"format.txt"</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">format_to</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">file</span><span class="p">),</span> <span class="s">"hello, {}!"</span><span class="p">,</span> <span class="s">"world"</span><span class="p">);</span>
</pre></table></code></div></div><p>or a container:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">format_to</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="s">"hello, world!"</span><span class="p">);</span>
</pre></table></code></div></div><p>So far all the examples involved string arguments, but the format API supports all kind of types, as long as a formatter is available for them (More on this later). There are predefined formatters for built-in types (<code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">bool</code>, <code class="language-plaintext highlighter-rouge">std::string</code>, <code class="language-plaintext highlighter-rouge">std::chrono::duration</code>, etc) so in most cases It Will Just Work:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;chrono&gt;
#include &lt;format&gt;
</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">dont_panic</span> <span class="o">=</span>
    <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"Just {} days left for the release, right?"</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">days</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
</pre></table></code></div></div><p>Formatters not only return a string representation of a value, but also allow to customize the output through formatting specifiers. <a href="https://en.cppreference.com/w/cpp/utility/format/formatter">These specifiers</a> are specific to each type formatter, for example the floating-point formatters implements precision config:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// Save pi as a string with three decimals of precision:</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{:.3f}"</span><span class="p">,</span> <span class="mf">3.141592654</span><span class="p">);</span>
</pre></table></code></div></div><p>or you can use type options to control how values are displayed:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">id</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{:#x}"</span><span class="p">,</span> <span class="mh">0xa</span><span class="p">);</span> <span class="c1">// "0xa"</span>
</pre></table></code></div></div><h2 id="integrating-user-defined-types">Integrating user defined types</h2><p>To make our types work with <code class="language-plaintext highlighter-rouge">&lt;format&gt;</code> there are two ways:</p><ul><li>Overload <code class="language-plaintext highlighter-rouge">operator&lt;&lt;</code> for <code class="language-plaintext highlighter-rouge">std::ostream</code> (As usual with the stream API).<li>Write a custom formatter for your type</ul><p>The first way is probably the most simple. <code class="language-plaintext highlighter-rouge">&lt;format&gt;</code> interoperates with the streams library so that any type compatible with output streams is compatible with the formatting library:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;ostream&gt;
#include &lt;format&gt;
</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">State</span>
<span class="p">{</span>
    <span class="n">On</span><span class="p">,</span>
    <span class="n">Off</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">State</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">State</span><span class="o">::</span><span class="n">On</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">"On"</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">State</span><span class="o">::</span><span class="n">Off</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">"Off"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// unreachable</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">...</span>

<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">current_mode</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"current mode is {}"</span><span class="p">,</span> <span class="n">Mode</span><span class="o">::</span><span class="n">On</span><span class="p">);</span>
</pre></table></code></div></div><p>This has the disadvantage that you add the performance overhead of streams into the formatting, but it’s the easiest way to migrate your existing types to <code class="language-plaintext highlighter-rouge">&lt;format&gt;</code> if you already integrated them with <code class="language-plaintext highlighter-rouge">ostream</code>.</p><p>Writing a custom formatter involves specializing the <a href="https://en.cppreference.com/w/cpp/utility/format/formatter"><code class="language-plaintext highlighter-rouge">std::formatter</code> template</a> for your type:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">std</span><span class="o">::</span><span class="n">formatter</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">format_parse_context</span><span class="o">::</span><span class="n">iterator</span> <span class="n">parse</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">format_parse_context</span><span class="o">&amp;</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
       <span class="p">...</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">format_parse_context</span><span class="o">::</span><span class="n">iterator</span> <span class="n">format</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">State</span> <span class="n">state</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="n">format_context</span><span class="o">&amp;</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
       <span class="p">...</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>The specialization must contain two member functions:</p><ul><li><p><code class="language-plaintext highlighter-rouge">parse(context)</code>: In charge of parsing the format specifications in the argument placeholder (If there’s any). That is, it is the function that parses what’s inside the “{}” placeholders of the format strings. If any specifier is found, it must be stored in the <code class="language-plaintext highlighter-rouge">std::formatter</code> object (<code class="language-plaintext highlighter-rouge">this</code> in the context of the function).</p><li><p><code class="language-plaintext highlighter-rouge">format(value, context)</code>: Formats the given value into the given output formatting context, applying any formatting specification found previously by <code class="language-plaintext highlighter-rouge">parse()</code>. For formatting to a given context you can simply call <code class="language-plaintext highlighter-rouge">std::format_to()</code> with the iterator provided by the context.</p></ul><p>We will not cover parsing in depth here (That are <a href="https://fmt.dev/latest/api.html#formatting-user-defined-types">good reference examples</a>) because most of the time you’re better off <strong>inheriting from an existing formatter that does the complicated stuff for you</strong>:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">std</span><span class="o">::</span><span class="n">formatter</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">formatter</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Context</span><span class="p">&gt;</span>
    <span class="k">auto</span> <span class="n">format</span><span class="p">(</span><span class="k">const</span> <span class="n">State</span> <span class="n">state</span><span class="p">,</span> <span class="n">Context</span><span class="o">&amp;</span> <span class="n">context</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="k">case</span> <span class="n">State</span><span class="o">::</span><span class="n">On</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">formatter</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;::</span><span class="n">format</span><span class="p">(</span><span class="s">"On"</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
        <span class="k">case</span> <span class="n">State</span><span class="o">::</span><span class="n">Off</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">formatter</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;::</span><span class="n">format</span><span class="p">(</span><span class="s">"Off"</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// unreachable</span>
        <span class="k">return</span> <span class="n">context</span><span class="p">.</span><span class="n">out</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="about-fmt">About fmt</h2><p>The standard <code class="language-plaintext highlighter-rouge">&lt;format&gt;</code> API is the result of Victor Zverovich’s work on <a href="https://fmt.dev/"><code class="language-plaintext highlighter-rouge">fmt</code></a>, an open source library. Currently <code class="language-plaintext highlighter-rouge">fmt</code> implements a subset of features common to the standard <code class="language-plaintext highlighter-rouge">&lt;format&gt;</code> plus some extra nice features:</p><ul><li><code class="language-plaintext highlighter-rouge">fmt::print()</code> as substitute for <code class="language-plaintext highlighter-rouge">std::cout</code>.<li>Colored output with foreground and background modifiers.<li>Built-in support for formatting containers</ul><p>The library is available <a href="https://github.com/fmtlib/fmt">on github</a> and <a href="https://conan.io/center/fmt">the major C++</a> <a href="https://fmt.dev/dev/usage.html#vcpkg">package managers</a>.</p></div><div class="post-tail-wrapper text-muted"><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c%2B%2B20/" class="post-tag no-text-decoration" >C++20</a> <a href="/tags/fmt/" class="post-tag no-text-decoration" >fmt</a> <a href="/tags/std-format/" class="post-tag no-text-decoration" >std-format</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=String formatting the cool way with C++20 std::format() - Madrid C/C++&url=https://madridccppug.github.io/posts/stdformat/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=String formatting the cool way with C++20 std::format() - Madrid C/C++&u=https://madridccppug.github.io/posts/stdformat/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=String formatting the cool way with C++20 std::format() - Madrid C/C++&url=https://madridccppug.github.io/posts/stdformat/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"><h3 data-toc-skip>Recent Update</h3><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/stdformat/">String formatting the cool way with C++20 std::format()</a></ul></div><div id="access-tags"><h3 data-toc-skip>Trending Tags</h3><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c++20/">C++20</a> <a class="post-tag" href="/tags/fmt/">fmt</a> <a class="post-tag" href="/tags/std-format/">std format</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><h3 data-toc-skip class="pl-3 pt-2 mb-2">Contents</h3><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div class="post-navigation d-flex justify-content-between"> <span class="btn btn-outline-primary disabled"><p>-</p></span> <span class="btn btn-outline-primary disabled"><p>-</p></span></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/madridccppug">madridccppug</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/c++20/">C++20</a> <a class="post-tag" href="/tags/fmt/">fmt</a> <a class="post-tag" href="/tags/std-format/">std format</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://madridccppug.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script>
